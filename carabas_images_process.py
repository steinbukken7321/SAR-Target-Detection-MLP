# -*- coding: utf-8 -*-
"""Carabas_Images-Process.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pmzd4NT8lx5Wj-tdyuTQOhRVDPcYuVew

## Leitura das imagens do CARABAS-II
conjunto de 24 imagens de 3000x2000
"""

import os
import cv2

# 1. Configurações de acesso
REPO_URL = "https://github.com/steinbukken7321/CARABAS-II-SAR-Dataset-Mirror.git"
REPO_NAME = "CARABAS-II-SAR-Dataset-Mirror"
PATH_TO_IMG = f"{REPO_NAME}/img"

# 2. Clonagem do repositório
# Verifica se a pasta do repositório já existe para não clonar novamente
if not os.path.exists(REPO_NAME):
    print("Baixando repositório do GitHub...")
    os.system(f"git clone {REPO_URL}")

# 3. Verificação do diretório de imagens
if not os.path.exists(PATH_TO_IMG):
    print(f"Erro: A pasta {PATH_TO_IMG} não foi encontrada no repositório clonado.")
    # Lista o conteúdo para ajudar no diagnóstico
    if os.path.exists(REPO_NAME):
        print(f"Conteúdo do repositório: {os.listdir(REPO_NAME)}")
else:
    print(f"Pasta {PATH_TO_IMG} localizada com sucesso.")

# 4. Leitura das imagens
valid_extensions = ('.png', '.jpg', '.jpeg', '.tif', '.bmp', '.mat')
image_files = [f for f in os.listdir(PATH_TO_IMG) if f.lower().endswith(valid_extensions)]

print(f"Arquivos encontrados: {len(image_files)}")

carabas_images = []
for filename in image_files:
    full_path = os.path.join(PATH_TO_IMG, filename)
    img = cv2.imread(full_path, cv2.IMREAD_UNCHANGED)

    if img is not None:
        carabas_images.append(img)

print(f"Total de imagens carregadas na memória: {len(carabas_images)}")

"""### Visualização do conjunto de imagens do CARABAS-II"""

import matplotlib.pyplot as plt

# Verificação se a lista contém imagens antes de tentar plotar
if len(carabas_images) > 0:
    print(f"Exibindo {len(carabas_images)} imagens do dataset CARABAS-II...")

    for i, img in enumerate(carabas_images):
        plt.figure(figsize=(8, 6))

        # Como são dados SAR, exibimos em escala de cinza (gray)
        # O Matplotlib ajusta automaticamente a escala de visualização para o range dos dados
        plt.imshow(img, cmap='gray')

        plt.title(f"Amostra SAR {i+1} - Resolução: {img.shape}")
        plt.axis('off')  # Oculta os eixos para melhor visualização
        plt.show()
else:
    print("Nenhuma imagem disponível para exibição. Verifique se o diretório contém arquivos válidos.")

"""## Implementação do Zero Padding no conjunto de imagens"""

import os
import cv2
import numpy as np

# ==========================================
# CONFIGURAÇÃO SIMPLES
# Mude o valor abaixo para alterar o tamanho do padding (1, 2, 5, etc)
padding_size = 1
# ==========================================

# 1. Definição dos caminhos
REPO_NAME = "CARABAS-II-SAR-Dataset-Mirror"
PATH_TO_IMG = f"{REPO_NAME}/img"
OUTPUT_DIR = "zero_padding_conjunto"

# Verifica se a pasta de origem existe
if os.path.exists(PATH_TO_IMG):
    # Cria a pasta de destino se não existir
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)
        print(f"Pasta '{OUTPUT_DIR}' criada.")

    # 2. Listagem dos arquivos
    valid_extensions = ('.png', '.jpg', '.jpeg', '.tif', '.bmp')
    image_files = [f for f in os.listdir(PATH_TO_IMG) if f.lower().endswith(valid_extensions)]

    print(f"Processando {len(image_files)} imagens com padding de {padding_size}px...")
    print("-" * 50)

    # 3. Processamento individual
    for filename in image_files:
        img_path = os.path.join(PATH_TO_IMG, filename)
        img = cv2.imread(img_path, cv2.IMREAD_UNCHANGED)

        # Verificação simples sem 'try'
        if img is not None:
            # Pegamos o shape original (Altura, Largura)
            h, w = img.shape[:2]

            # Aplica o padding em todas as bordas
            img_padded = np.pad(
                img,
                ((padding_size, padding_size), (padding_size, padding_size)),
                mode='constant',
                constant_values=0
            )

            # Salva a nova imagem
            save_path = os.path.join(OUTPUT_DIR, filename)
            cv2.imwrite(save_path, img_padded)

            # Exibe o log seguindo a ordem (Altura x Largura) do shape
            print(f"Arquivo: {filename}")
            print(f"  > Original (H x W): {h} x {w}")
            print(f"  > Padded   (H x W): {img_padded.shape[0]} x {img_padded.shape[1]}")
            print("-" * 30)

"""### Leitura das imagens após zero padding"""

import os
import cv2
import matplotlib.pyplot as plt

# 1. Caminho da pasta onde salvamos as imagens com padding
OUTPUT_DIR = "zero_padding_conjunto"

# 2. Listagem dos arquivos na pasta de padding
if os.path.exists(OUTPUT_DIR):
    valid_extensions = ('.png', '.jpg', '.jpeg', '.tif', '.bmp')
    padded_files = sorted([f for f in os.listdir(OUTPUT_DIR) if f.lower().endswith(valid_extensions)])

    if len(padded_files) > 0:
        print(f"Exibindo {len(padded_files)} imagens com Zero Padding...")

        for i, filename in enumerate(padded_files):
            # Carrega a imagem da nova pasta
            full_path = os.path.join(OUTPUT_DIR, filename)
            img = cv2.imread(full_path, cv2.IMREAD_UNCHANGED)

            # Verifica se a imagem foi carregada com sucesso antes de plotar
            if img is not None:
                plt.figure(figsize=(8, 6))

                # Exibição em escala de cinza (padrão SAR)
                plt.imshow(img, cmap='gray')

                # Título com o nome do arquivo e a nova resolução (Altura x Largura)
                plt.title(f"Padded {i+1}: {filename}\nResolução: {img.shape}")

                plt.axis('off')  # Oculta os eixos
                plt.show()

"""## Implementação de Filtro de Média de 3x3 no conjunto de imagens Zero Padding"""

import os
import cv2
import numpy as np

# ==========================================
# CONFIGURAÇÃO SIMPLES
# kernel_size: Tamanho da janela do filtro (3 para 3x3, 5 para 5x5, etc)
# Deve ser um número ímpar (3, 5, 7...)
kernel_size = 3
# ==========================================

# 1. Definição dos caminhos
# Utilizamos a pasta do zero padding como origem
INPUT_DIR = "zero_padding_conjunto"
OUTPUT_DIR_FILTER = "filtro_media_movel_conjunto"

# Verifica se a pasta de origem (padded) existe
if os.path.exists(INPUT_DIR):
    # Cria a pasta de destino para o filtro se não existir
    if not os.path.exists(OUTPUT_DIR_FILTER):
        os.makedirs(OUTPUT_DIR_FILTER)
        print(f"Pasta '{OUTPUT_DIR_FILTER}' criada.")

    # 2. Listagem dos arquivos da pasta padded
    valid_extensions = ('.png', '.jpg', '.jpeg', '.tif', '.bmp')
    image_files = [f for f in os.listdir(INPUT_DIR) if f.lower().endswith(valid_extensions)]

    print(f"Aplicando filtro de média móvel ({kernel_size}x{kernel_size}) em {len(image_files)} imagens...")
    print("-" * 50)

    # 3. Processamento individual
    for filename in image_files:
        img_path = os.path.join(INPUT_DIR, filename)
        img = cv2.imread(img_path, cv2.IMREAD_UNCHANGED)

        # Verificação simples sem 'try'
        if img is not None:
            # Pegamos o shape da imagem com padding
            h, w = img.shape[:2]

            # Aplica o filtro de média móvel (Blur/Box Filter)
            # O ksize define a área de vizinhança que será calculada
            img_filtered = cv2.blur(img, (kernel_size, kernel_size))

            # Salva a nova imagem filtrada
            save_path = os.path.join(OUTPUT_DIR_FILTER, filename)
            cv2.imwrite(save_path, img_filtered)

            # Exibe o log
            print(f"Arquivo: {filename}")
            print(f"  > Resolução mantida: {h} x {w}")
            print(f"  > Filtro aplicado: Média Móvel {kernel_size}x{kernel_size}")
            print("-" * 30)

    print(f"\nConcluído! As imagens filtradas estão em: {OUTPUT_DIR_FILTER}")
else:
    print(f"Erro: A pasta '{INPUT_DIR}' não foi encontrada. Certifique-se de rodar o código de padding primeiro.")

"""### Leitura das imagens após filtro"""

import os
import cv2
import matplotlib.pyplot as plt

# 1. Caminho da pasta das imagens filtradas
OUTPUT_DIR_FILTER = "filtro_media_movel_conjunto"

# 2. Verificação e listagem dos arquivos
if os.path.exists(OUTPUT_DIR_FILTER):
    valid_extensions = ('.png', '.jpg', '.jpeg', '.tif', '.bmp')
    filtered_files = sorted([f for f in os.listdir(OUTPUT_DIR_FILTER) if f.lower().endswith(valid_extensions)])

    if len(filtered_files) > 0:
        print(f"Exibindo {len(filtered_files)} imagens com Filtro de Média Móvel...")

        for i, filename in enumerate(filtered_files):
            # Carrega a imagem da pasta de filtros
            full_path = os.path.join(OUTPUT_DIR_FILTER, filename)
            img = cv2.imread(full_path, cv2.IMREAD_UNCHANGED)

            # Verificação simples sem 'try'
            if img is not None:
                plt.figure(figsize=(8, 6))

                # Exibição em escala de cinza
                plt.imshow(img, cmap='gray')

                # Título com o índice, nome do arquivo e resolução (H x W)
                plt.title(f"Filtrada {i+1}: {filename}\nResolução: {img.shape[0]} x {img.shape[1]}")

                plt.axis('off')  # Oculta os eixos
                plt.show()
    else:
        print(f"A pasta '{OUTPUT_DIR_FILTER}' está vazia.")
else:
    print(f"Erro: A pasta '{OUTPUT_DIR_FILTER}' não encontrada. Execute a célula do filtro primeiro.")

"""## Histogramas

### Conjunto original x Conjunto Filtrado
"""

import os
import cv2
import matplotlib.pyplot as plt

# 1. Caminhos dos diretórios
REPO_NAME = "CARABAS-II-SAR-Dataset-Mirror"
ORIGINAL_DIR = f"{REPO_NAME}/img"
FILTERED_DIR = "filtro_media_movel_conjunto"

# 2. Listagem e ordenação para garantir que comparamos a mesma imagem
if os.path.exists(ORIGINAL_DIR) and os.path.exists(FILTERED_DIR):
    valid_extensions = ('.png', '.jpg', '.jpeg', '.tif', '.bmp')
    original_files = sorted([f for f in os.listdir(ORIGINAL_DIR) if f.lower().endswith(valid_extensions)])

    print(f"Iniciando comparação de histogramas para {len(original_files)} imagens...")

    for filename in original_files:
        path_orig = os.path.join(ORIGINAL_DIR, filename)
        path_filt = os.path.join(FILTERED_DIR, filename)

        # Verifica se o arquivo correspondente existe na pasta de filtros
        if os.path.exists(path_filt):
            img_orig = cv2.imread(path_orig, cv2.IMREAD_UNCHANGED)
            img_filt = cv2.imread(path_filt, cv2.IMREAD_UNCHANGED)

            if img_orig is not None and img_filt is not None:
                # Criando a figura para comparação
                fig, axs = plt.subplots(2, 2, figsize=(15, 10))
                fig.suptitle(f"Comparação: {filename}", fontsize=16)

                # --- LADO ESQUERDO: ORIGINAL ---
                # Imagem
                axs[0, 0].imshow(img_orig, cmap='gray')
                axs[0, 0].set_title(f"Original - {img_orig.shape}")
                axs[0, 0].axis('off')

                # Histograma
                # .ravel() transforma a matriz em um array plano para o histograma
                axs[1, 0].hist(img_orig.ravel(), bins=256, range=[0, 256], color='black')
                axs[1, 0].set_title("Histograma Original")
                axs[1, 0].set_xlabel("Intensidade de Pixel")
                axs[1, 0].set_ylabel("Frequência")

                # --- LADO DIREITO: FILTRADA ---
                # Imagem
                axs[0, 1].imshow(img_filt, cmap='gray')
                axs[0, 1].set_title(f"Filtrada (Média Móvel) - {img_filt.shape}")
                axs[0, 1].axis('off')

                # Histograma
                axs[1, 1].hist(img_filt.ravel(), bins=256, range=[0, 256], color='blue', alpha=0.7)
                axs[1, 1].set_title("Histograma Filtrado")
                axs[1, 1].set_xlabel("Intensidade de Pixel")
                axs[1, 1].set_ylabel("Frequência")

                plt.tight_layout(rect=[0, 0.03, 1, 0.95])
                plt.show()
                print("-" * 50)
else:
    print("Erro: Certifique-se de que ambas as pastas existem.")

"""###"""